## 第三章

### 闭包

1. 封装变量&提炼函数
如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。
```js
var mult = (function() {
  var cache = {};
  var calculate = function() {
    var a = 1;
    for (var i = 0; l = arguments.length; i < l; i++) {
      a = a * arguments[i];
    }
    return a;
  };

  return function() {
    var args = Array.prototype.join.call(arguments, ',');
    if (args in cache) {
      return cache[args];
    }
    return cache[args] = calculate.apply(null, arguments);
  }
})();

mult(1, 2, 3)
```

上面这段代码，有两个地方是自己平时不会这样写的，都是在最后一行：

    1. `return cache[args] = calculate.apply(null, arguments);`返回值此处利用了赋值表达式的返回结果;

    2. `calculate.apply(null, arguments)`中`calculate`的调用使用了`apply`，如果用普通函数传参调用会导致上面`calculate`函数中的`arguments.length=1`。所以要使用`apply`调用。

2. 延续局部变量的寿命

### 闭包和面向对象设计

对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。**通常用面向对象思想能实现的功能，用闭包也能实现。**卧槽，从没这么想过诶！！！闭包的地位竟然这么高！！！

使用闭包实现的一段代码：

```js
var extent = function(){
  var value = 0;
  return {
    call: function(){
      value++;
      console.log( value );
    }
  }
};
var extent = extent();
extent.call(); // 输出:1
extent.call(); // 输出:2
extent.call(); // 输出:3
```

使用面向对象实现相同的结果：

```js
var extent = {
  value: 0,
  call: function(){
    this.value++;
    console.log( this.value );
  }
};
extent.call(); // 输出:1
extent.call(); // 输出:2
extent.call(); // 输出:3

或者

var Extent = function(){
  this.value = 0;
}; 

Extent.prototype.call = function(){
  this.value++;
  console.log( this.value );
}; 

var extent = new Extent();

extent.call();
extent.call();
extent.call();
```

### 闭包与内存管理

如果在将来要回收这些变量，可以手动把这些变量设为null。