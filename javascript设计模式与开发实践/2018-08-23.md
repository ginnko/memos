## 第七章 迭代器模式

### 内部迭代器和外部迭代器

迭代器分为**内部迭代器**和**外部迭代器**。

内部迭代器就是我们平时用的最多的循环。

下面是一个外部迭代器的示例代码：

```js
var Iterator = function(obj) {
  var current = 0;
  var next = function() {
    current += 1;
  };
  var isDone = function() {
    return current >= obj.length;
  };

  var getCurrentItem = function() {
    return obj[current];
  };

  return {
    next: next,
    isDone: isDone,
    getCurrentItem: getCurrentItem
  };
};

// compare函数的实现
var compare = function(iterator1, iterator2) {
  while(!iterator1.isDone() && !iterator2.isDone()) {
    if (iterator1.getCurrentItem() !== iterator2.getCurrentItem()) {
      throw new Error('iterator1和iterator2不相等！');
    }
    iterator1.next();
    iterator2.next();
  }
  console.log('iterator1和iterator2相等。');
};

const arr1 = [1, 2, 3，6];
const arr2 = [1, 2, 3, 4];

const iterator1 = Iterator(arr1);
const iterator2 = Iterator(arr2);
compare(iterator1, iterator2);
```

可以看到外部迭代器的调用需要显示地请求迭代下一个元素，需要自己写代码控制迭代的过程。

### 迭代类数组对象和字面量对象

无论内部迭代器还是外部迭代器，**只要被迭代的聚合对象拥有length属性并且可以用下标方法，那它就可以被迭代**。

```js
const each = function(obj, callback) {
  let value,
      i = 0,
      length = obj.length,
      isArray = isArrayLike(obj);
  if (isArray) {
    for (; i < length; i++) {
      value = callback.call(obj[i], i, obj[i]);
      if( value === false ) {
        break;
      }
    }
  } else {
    for ( i in obj ) {
      value = callback.call(obj[i], i, obj[i]);
      if (value === false) {
        break;
      }
    }
  }
  return obj;
};
```

### 倒序迭代器

下面的代码示例是一个倒序访问的迭代器的实现：

```js
var reverseEach = function(ary, callback) {
  for (var l = ary.length - 1; l >= 0; l--) {
    callback(l, ary[l]);
  }
};

// 使用
reverseEach([0, 1, 2], function(i, n) {
  console.log(n); // 分别求出2, 1, 0
});
```

### 中止迭代器

```js
var each = function(ary, callback) {
  for (var i = 0, l = ary.length; i < l; i++) {
    if (callback(i, ary[i]) === false) {
      break;
    }
  }
};

each([1, 2, 3, 4, 5], function(i, n) {
  if (n > 3) {
    return false;
  }
  console.log(n); // 分别输出1, 2, 3
});
```

### 迭代器模式的应用举例

一般的会写成下面这样的代码：

```js
var getUploadObj = function(){
  try{
    return new ActiveXObject("TXFTNActiveX.FTNUpload");// IE 上传控件
  }catch(e){
    if ( supportFlash() ){// supportFlash 函数未提供
      var str = '<object type="application/x-shockwave-flash"></object>';
      return $( str ).appendTo( $('body') );
    }else{
      var str = '<input name="file" type="file"/>'; // 表单上传
      return $( str ).appendTo( $('body') );
    }
  }
};
```

使用迭代器的方式，获取不同上传对象的方法被隔离在各自的函数里互不干扰，try， catch和if分支不再纠缠在一起，更方便的扩展和维护代码。

```js
// IE上传控件
var getActiveUploadObj = function(){
  try{
    return new ActiveXObject( "TXFTNActiveX.FTNUpload" );
  }catch(e){
    return false;
  }
};

// supportFlash 函数未提供
var getFlashUploadObj = function(){
  if ( supportFlash() ){
    var str = '<object type="application/x-shockwave-flash"></object>';
    return $( str ).appendTo( $('body') );
  }
  return false;
};

// 表单上传
var getFormUpladObj = function(){
  var str = '<input name="file" type="file" class="ui-file"/>';
  return $( str ).appendTo( $('body') );
};



// 迭代器代码
var iteratorUploadObj = function(){
  for ( var i = 0, fn; fn = arguments[ i++ ]; ){
    var uploadObj = fn();
    if ( uploadObj !== false ){
      return uploadObj;
    }
  }
};


// 调用
var uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUpladObj );
```