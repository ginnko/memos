### 第二章 用电信号传输TCP/IP数据

这一章是讲协议栈（网络控制软件）和网卡（网络硬件）。

1. 协议栈内部结构

![协议栈内部结构](./images/协议栈内部结构.png)

从图中可以看到，协议栈的上半部分有两块，分别是负责用TCP协议收发数据的部分和负责用UDP协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。**像浏览器、邮件等一般的应用程序都是使用TCP收发数据的，而像DNS查询等收发较短的控制数据的时候则使用UDP。**

2. 套接字的实体就是通信控制信息

在 **协议栈内部** 有一块用于 **存放控制信息的内存空间**，这里记录了用于控制通信操作的控制信息，例如通信对象的 **IP地址**、**端口号**、**通信操作的进行状态**等。套接字只是一个概念，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说是存放控制信息的内存空间就是套接字的实体。

*windows*中使用`webstat`来显示套接字，ubuntu中使用`ss`显示类似的信息，更多操作指令见[此处](https://blog.csdn.net/zeweig/article/details/51760624)。

3. 创建套接字

应用程序调用`socket`申请创建套接字。

**创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。**

在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们逍遥开辟u出来这样一块空间，相当与为控制信息准备了一个容器。套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。到这里，创建套接字的操作就完成了。

套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只需要通过描述符确定了相应的套接字，协议栈就能获取所有的相关信息。

4. 连接操作的含义

---
##### 插个嘴

这里插个嘴，之前的笔记里应该是有写错的地方，比如连接这里，书上的写法是：

>创建套接字之后，应用程序（浏览器）就会调用connect，协议栈会将本地的套接字与服务器的套接字进行连接

看到没，是浏览器调用了Socket库中的程序！！！
---

**连接的本质是双方交换控制信息**

套接字刚刚创建完成时，里面并没有存放任何数据，也不知道通信对象是谁。在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。**浏览器**可以根据网址来查询服务器的IP地址，而且根据规则也知道该使用80端口，但只有浏览器知道这些必要的信息是不够的，因为在调用socket创建套接字的时候，这些信息并没有传递给协议栈。因此，**我们需要把服务器的IP地址和端口号等信息告知协议栈，这是连接操作的目的之一。**

服务器上也会创建套接字，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁。 **客户端向服务器传达开始通信的请求，向服务器告知必要的信息，也是连接操作的目的之一。**

当执行数据首发操作时，我们还需要一块用来临时存放要首发的数据的内存空间，这块内存空间称为缓冲区，**它也是在连接操作的过程中分配的。**

##### 控制信息

**控制信息**:用来控制数据收发操作所需的一些信息。

第一类：是客户端和服务器相互联络时交换的控制信息。这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程中都需要。 *这些信息记录在网络包的头部。*

第二类：**保存在套接字中**，用来控制协议栈操作的信息。应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。 *协议栈具体需要哪些信息会根据协议栈本身的实现方式不同而不同。因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。*

5. 连接操作的实际过程

连接操作从应用程序调用Socket库的connect开始：

```
connect(< 描述符 >, < 服务器 IP 地址和端口号 >, ...)
```

上面的调用提供了服务器的IP地址和端口号，这些信息会传递给协议栈中的TCP模块。然后，TCP模块会与该IP地址对应的对象，也就是与服务器的TCP模块交换控制信息，这一交互过程包括下面几个步骤。

- 首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。
- 然后，我们将头部中的控制位的SYN比特设置为1，可以认为它表示连接；
- 当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送IP模块执行网络包发送操作之后，网络包机会通过网络到达服务器，然后服务器上的IP模块会将收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字。找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。
- 上述操作完成之后，服务器的TCP模块会返回响应，这个过程和客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特。此外，在返回响应时，还需要将ACK控制位设为1，表示已经收到相应的网络包。（**设置ACK比特的目的就是用来在双方通信过程中互相确认网络包是否已经送达。**）
- 接下来，服务器TCP模块会将TCP头部传递给IP模块，并将IP模块向客户端返回响应。然后，网络包就会返回客户端，通过IP模块到达TCP模块，并通过TCP头部的信息确认连接服务器的操作是否成功。如果SYN为1则表示连接成功，这时会向套接字中写入服务器的IP地址、端口号等信息，同时还会将状态改为连接完毕；
- 最后，服务器返回响应时将ACK比特设置为1，相应的，客户端也需要将ACK比特设置为1并返回服务器，告诉服务器刚才的响应包已经收到。当这个服务器收到这个返回包之后，连接操作才算全部完成。

6. 收发数据

```
write()
```

数据收发操作是从应用程序调用`write`将要发送的数据交给协议栈开始的，协议栈收到数据后执行发送操作。

要点：

- 协议栈不关心应用程序传来的数据是什么内容。应用程序在调用`write`时会指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。
- 协议栈并不是一收到数据就马上发送出去，而是会将数据存放在 **内部的发送缓冲区** (*这个缓冲区是什么时候创建的？连接阶段？*)中，并等待应用程序的下一段数据。一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为。

    发送大量的小包会导致网络效率降低。

    判断网络包的大小：

    1. 协议栈会根据一个叫作`MTU`的参数来进行判断。`MTU`表示一个网络包的最大长度，在以太网中一般是1500字节。MTU是包含头部的总长度，因此需要从`MTU`减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作`MSS`。当从应用程序收到的数据长度超过或者接近MSS时再发送出去，就可以避免发送大量小包的问题了。
    2. 另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近MSS时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到MSS，也应该发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。

    上面两个因素是互斥的，协议栈给应用程序保留了控制发送时机的余地。像浏览器这种会话型应用程序再向服务器发送数据时，等待填满缓冲区会导致延迟产生很大影响，因此一般会使用直接发送的选项。

    ##### 对较大数据进行拆分

    提交数据的情况，比如在博客或者论坛上发表一篇长文就属于这种情况。


    ![TCP拆分包](./images/TCP拆分包.PNG)

- 使用ACK号确认网络包已收到

    TCP具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。

    ###### 确认原理

    - 首先，TCP模块在拆分数据时，会先计算好每一块数据相当于 **从头开始的第几个字节**，接下来在发送这一块数据时，将算好的字节数写在TCP头部中，“序号”字段就是派在这个用场上的。
    - 然后，发送数据的长度也需要告知接收方，不过这个并不是放在TCP头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度。

    通过这些信息，接收方还能够检查收到的网络包有没有遗漏，如果确认没有遗漏，接收方会将到目前为止接受到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入TCP头部的ACK号中发送给发送方。这个返回ACK号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据。

    在实际的通信中，序号并不是从1开始的，而是需要用随机数计算出一个初始值，这时因为如果需要都从1开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。**在连接过程中，有一个将SYN控制位设为1并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。实际上，在将SYN设为1的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值。**

    - 双向通信的过程原理：首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算ACK号并返回给客户端；相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算ACK号并返回给服务器。此外，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。

    TCP采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存的发送缓冲区中。如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。

    **ACK号目测是唯一的保证机制，网卡、集线器、路由器都没有补偿机制。如果发生网络中断、服务器宕机等问题，那么无论TCP怎样重传都不管用。这种情况下，无论如何尝试都是徒劳。因此TCP会在尝试几次重传无效之后强制结束通信，并向应用程序报错。**

    - 根据网络包平均往返事件调整ACK号等待时间

        - 返回ACK号的等待时间（超时时间）

        TCP采用了动态调整等待时间的方法，这个等待事件是根据ACK号返回所需的时间来判断的。具体来说，TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；相对地，如果ACK号马上就能返回，则相应缩短等待时间。

    - 滑动窗口方式发送数据包

        滑动窗口：就是在发送一个包之后，不等待ACK号返回，而是直接发送后续的一系列包。这样一来，等待ACK号的这段事件就被有效利用起来了。
        
        窗口大小：能够接收的最大数据量。

        接收方会通过TCP头部中的窗口字段将自己能接收的数据量告知发送方。这样一来，发送方就不会发送过多的数据，导致超出接收方的处理能力了。

        ![滑动窗口与接收缓冲区](./images/滑动窗口与接收缓冲区.png)

    - ACK与窗口的合并

        - 更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候
        - 返回ACK号的时机因该是当接收方收到数据，确认内容没有问题的时候

        最佳的操作是，接收方在发送ACK号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，这样就可以把两种通知合并在一个包里面发送了。当需要连续发送多个ACK号时，可以只发送最后一个ACK号，中间的可以全部省略。同样的，当需要连续发送多个窗口更新时，可以省略中间过程，只发送最终的结果就可以了。上面的操作都可以减少包的发送数量。


7. 接收HTTP响应消息
   
   首先浏览器在委托协议栈发送请求消息之后，会调用`read`程序来`获取`响应消息。然后，控制流程会通过read转移到协议栈，之后，协议栈会执行接下来的操作。和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中。如果响应消息没有返回，接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。

   协议栈会检查接收道德数据块和TCP头部的内容，判断是否有数据丢失，如果没有问题则返回ACK号。然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，将数据复制到应用程序执行的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还需要找到合适的时机，向发送方发送窗口更新。

8. 从服务器断开并删除套接字

    - 断开连接
      
      在HTTP1.1中，服务器返回响应消息之后，客户端还可以继续发起下一个请求消息，如果接下来没有请求要发送了，**客户端**一方会发起断开过程。

      服务器一方发起的断开过程的说明：

      首先，服务器一方的应用程序会调用Socket库的close程序。然后，服务器的协议栈会生成包含断开信息的TCP头部，具体来说就是将控制位中的FIN比特设为1。接下来，协议栈会委托IP模块向客户端发送数据。同时，服务器的套接字中也会记录下断开操作的相关信息。

      接下来轮到客户端。当接收到服务器发来的FIN为1的TCP头部时，客户端的协议栈会将自己的套接字标记为进入断开操作的状态。然后，为了告知服务器已收到FIN为1的包，客户端会想服务器返回一个ACK号。这些操作完成之后，协议栈就可以等待应用程序来取数据了。

      过了一会儿，应用程序就会调用read来读取数据。这时，协议栈不会向应用程序传递数据，而是会告诉应用程序（浏览器）来自服务器的数据已经全部收到了。客户端应用程序会调用close来结束数据收发操作，这时客户端的协议栈也会服务器一样，生成一个FIN比特为1的TCP包，然后委托IP模块发送给服务器。一段时间之后，服务器就会返回ACK号。到这里，客户端和服务器的通信就全部结束了。

    - 删除套接字
    
      和服务器的通信结束之后，套接字并不会立即被删除，而是会等待一段事件之后再被删除。等待这段时间是为了防止误操作。

9. 数据收发操作小结

数据收发操作的第一步是创建套接字。一般来说，服务器一方的应用程序在启动时就会创建好套接字并进入等待连接的状态。客户端则一般是在用户触发特定动作，需要访问服务器的时候创建套接字。在这个阶段，还没有开始传输网络包。

创建套接字之后，客户端会向服务器发起连接操作。首先，客户端会生成一个SYN为1的TCP包并发送给服务器。这个TCP包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要用到的窗口大小。当这个包到达服务器之后，服务器会返回一个SYN为1的TCP包。这个包的头部中也包含了序号和窗口大小，此外还包含表示确认已收到包的ACK号。当这个包到达客户端时，客户端会向服务器返回一个包含表示确认的ACK号的TCP包。到这里，连接操作就完成了，双方进入数据收发阶段。

数据收发阶段的操作根据应用程序的不同而有一些差异，以web为例，首先客户端会向服务器发送请求消息。TCP会将请求消息切分成一定大小的块，并在每一块前面加上TCP头部，然后发送给服务器。TCP头部中包含序号，它表示当前发送的是第几个字节的数据。当服务器收到数据时，会向客户端返回ACK号。在最初的阶段，服务器只是不断接收数据，随着数据收发的进行，数据不断传递给应用程序，接受缓冲区就会被逐步释放。这时，服务器需要将新的窗口大小告知客户端。当服务器收到客户端的请求消息后，会向客户端返回响应消息，这个过程和刚才的过程正好相反。

服务器的响应消息发送完毕之后，数据收发操作就结束了，这时就会开始执行断开操作。以web为例，服务器会先发起断开过程（在HTTP1.1中，有可能是客户端发起断开过程）。在这个过程中，服务器先发送一个FIN为1的TCP包，然后客户端返回一个表示确认收到的ACK号。接下来，双方还会交换一组方向相反的FIN为1的TCP包和包含ACK号的TCP包。最后，在等待一段时间后，套接字会被删除。




10. 包的基本知识

    - 包是由 **头部** 和 **数据** 两部分构成。

    创建包的过程就是生成含有正确控制信息的头部，然后再附上要发送的数据。接下来，包会被发往最近的网络转发设备。当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向。

    - 路由器和集线器

        1. 路由器根据目标地址判断下一个路由器的位置

        2. 集线器在子网中将网络包传输到下一个路由

        集线器是按照以太网规则传输包的设备，路由器是按照IP规则传输报的设备。

        TCP/IP包包含如下两个头部：MAC头部（用于以太网协议）和IP头部（用于IP协议）。这两个头部分别具有不同的作用。首先，发送方将包的目的地，也就是要访问的服务器的IP地址写入IP头部中。这样一来，我们就知道这个包应该发往哪里。IP协议就可以根据这一地址查询包的传输方向。从而找到下一个路由器的位置。

        接下来，IP协议会委托以太网协议将包传输过去。这时，IP协议会查找下一个路由器的以太网地址（MAC地址），并将这个地址写入MAC头部中。这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。

        网络包在传输过程中会经过集线器，集线器是根据以太网协议工作的设备。为了判断包接下来应该向什么地方传输，集线器里有一张表（用于以太网协议的表），可根据以太网头部中记录的目的地信息查出相应的传输方向。

        接下来，包会到达下一个路由器。路由器中有一张IP协议表，可以根据这张表以及IP头部中记录的目的地信息查出来接下来应该发往哪个路由器，为了将包发到下一个路由器，我们还需要查出下一个路由器的MAC地址，并记录到MAC头部中。

        之所以将IP和以太网分开，是因为以太网的部分可以替换成其他的东西，如无线局域网、ADSL等，它们都可以替代以太网的角色帮助IP协议来传输网络包。因此，将IP和负责传输的网络分开，可以更好滴根据需要使用各种通信技术。

11. IP模块

    IP模块负责添加如下两个头部：

    1. MAC头部：以太网用的头部，包含MAC地址
    2. IP头部：IP用的头部，包含IP地址

    TCP模块在收发数据时会分为好几个阶段，并未各个阶段设计了实现相应功能的网络包，但IP的包收发操作都是相同的，并不会因为包本身而有所区别。因为IP模块会将TCP头部和数据块看做一整块二进制数据，在执行收发操作时，并不关心其中的内容，也不关心这个包是包含TCP头部和数据两者都有，还是只有TCP头部而没有数据。IP模块也不关心TCP的操作阶段，对于包的乱序和丢失也一概不知。

    IP模块的职责就是将委托的东西打包送到对方手里，或者是将对方送来的包接收下来，仅此而已。

12. 网络设备（网卡）
    
    传递给网卡的网络包是由一连串0和1组成的数字信息，**网卡会将这些数字信息转换成电信号或是光信号**，并通过网线（或光纤）发送出去，然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步送达接收方。

    接收的过程和发送的过程是相反的，信息先以电信号的形式从网线传输进来，然后 **由网卡将其转换为数字信息并传递给IP模块**。接下来，IP模块会将MAC头部和IP头部后面的内容，也就是TCP头部加上数据块，传递给TC模块。

13. 生成包含接收方IP地址的IP头部

    IP地址实际上并不是分配给计算机的，而是分配给网卡的，因此当计算机上存在多块网卡时，每一块网卡都会有自己的IP地址。很多服务器上都会安装多块网卡，这时一台计算机就会有多个IP地址，在填写发送方IP地址时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪一块网卡来发送这个包，也就相当于判断应该把包发往哪个路由器，因此只要确定了目标路由器，也就确定了应该使用哪块网卡，也就确定了发送方的IP地址。   


    windows下执行命令`route print`显示路由表。Interface列，表示网卡等网络接口，这些网络接口可以将包发送给通信对象。Gateway列表示下一个路由器的IP地址，将包发给这个IP，该地址对应的路由器就会将包转发到目标地址。如果Gateway和Interface列的IP地址相同，就表示不要路由器进行转发，可以直接将包发送给接收方的IP地址。路由表的第1行中，目标地址和子网掩码都是0.0.0.0，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配到这一行。

    除了IP地址，还需要填写协议号，它表示包的内容来自哪个模块。如果TCP模块委托的内容，则设置为06（十六进制），如果是UDP模块委托的内容，则设置17（十六进制）。HTTP请求消息都是通过TCP来传输的，因此这里就会填写表示TCP的06。

14. 生成以太网用的MAC头部

    MAC头部的开头是接收方和发送方的MAC地址，和IP头部中的接收方和发送方IP地址的功能差不多，只不过IP地址的长度为32比特，而MAC地址为48比特。在IP中，协议号表示IP头部后面的包内容的类型；而在以太网中，我们可以认为以太网类型后面就是以太网包的内容，而以太类型就是表示后面内容的类型。

    对于多块网卡的情况，设置发送方IP地址时，我们已经判断出了从哪块网卡发送这个包，那么现在只要将这块网卡对应的MAC地址填进去就好了。

    只要告诉以太网对方的MAC地址，以太网就会帮我们把包发送过去。然而，在这个时间点上，我们还没有把包发送出去，所以先得搞清楚应该把包发送给谁，这个只要查一下路由表就知道了。在路由表中找到相陪陪的条目，然后把包发给Gateway列中的IP地址就可以了。既然已经知道了包应该发给谁，那么只要将对方的MCA地址填上去就好了，但到这里为止，根本没有出现对方的MAC地址，也就是说我们现在根本不知道对方的MAC地址是什么。因此，我们还需要执行根据IP地址查询MAC地址的操作。

15. 通过ARP(Address Resolution Protocol，地址解析协议)查询目标路由器的MAC地址

    在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP就是利用了广播对所有设备进行操作。

    ![arp](./images/arp.PNG)

    查询arp缓存使用命令：`arp -a`。

    MAC头部是以太网需要的内容，并不属于 IP 的职责范围， 但从现实来看， 让 IP 负责整个打包工作是有利的。如果在交给网卡之前， IP 模块能够完成整个打包工作， 那么网卡只要将打好的包发送出去就可以了。 对于除 IP 以外的其他类型的包也是一样， 如果在交给网卡之前完成打包， 那么对于网卡来说， 发送的操作和发送 IP 包是完全相同的。 这样一来， 同一块网卡就可以支持各种类型的包。至于接收操作，我们到后面会讲， 但如果接收的包可以原封不动直接交给 IP 模块来处理， 网卡就只要负责接收就可以了。 

16. 以太网的基本知识

    以太网有三个性质：

    1. 将包发送到MAC头部的接收方MAC地址代表的目的地
    2. 用发送方MAC地址识别发送方
    3. 用以太类型识别包的内容

    具备这3个性质的网络就是以太网

17. 将IP包转换成电或光信号发送出去

    1. 网卡的初始化过程

    打开计算机启动操作系统的时候，网卡驱动程序会对硬件进行初始化操作，然后硬件才进入可以使用的状态。硬件通用的操作包括硬件错误检查、初始设置等步骤。以太网特有的操作包括：控制以太网收发操作的MAC模块中设置MAC（Media Access Control）地址。

    真正生效的是网卡驱动进行初始化时在MAC模块中设置的那个MAC地址，这个地址可能来自网卡的ROM，也可能来自其他命令或配置文件。

    2. 给网络包再加3个控制数据

    开头加上报头和起始帧分界符，结尾加上用于检测错误的帧校验序列。

    发送的信号是数据信号和时钟信号叠加而成的信号。根据报头，测量时钟信号，并从接收到的信号中将时钟信号提取出来，再根据原信号就可以计算出实际的数据信号。

    在包传输过程中，如果受到噪声的干扰而导致其中的数据发生了变化，那么接收方计算出的FCS和发送方计算出的FCS就会不同，这样我们就可以判断出数据有没有错误。

      - 报头（56比特）： 用来测量时钟信号的特殊信号
      - 起始帧分界符（8比特）：用来表示包起始位置的标记 
      - 帧校验序列（FCS，32比特）：用来检查包传输过程中因噪声导致的波形紊乱、数据错误。

18. 向集线器发送网络包
    
    首先，MAC模块从报头开始将数字信息按每个比特转换成电信号，然后由PHY或者叫MAU的信号收发模块发送出去。 **在这里，将数字信息转换为电信号的速率就是网络的传输速率**，例如每秒将10Mbit的数字信息转换为电信号发送出去，则速率就是10Mbit/s。

    网卡的MAC模块生成通用信号，然后由PHY（MAU）模块转换成可在网线中传输的格式，并通过网线发送出去。

    在半双工模式下，如果在信号开始发送到结束发送的这段时间内一直没有其他信号进来，发送操作就成功了。

19. 接收返回包

    在使用集线器的半双工模式以太网中，一台设备发送的信号会到达连接在集线器上的所有设备。这意味着无论是不是发给自己的信号都会通过接收线路传进来，因此接收操作的第一步就是把这些信号全都收进来。

    信号的开头是报头，通过报头的波形同步时钟，然后遇到起始帧分界符开始将后面的信号转换成数字信息。这个操作和发送时是相反的，即PHY（MAU）模式先开始工作，然后再轮到MAC模块。首先，PHY模块会将信号转换成通用格式并发送给MAC模块，MAC模块再从头开始将信号转换成数字信息，并存放到缓冲区中。当到达信号的末尾时，还需要检查FCS。具体来说，就是讲包从开头到结尾的所有比特套用到公式中，计算出FCS，然后和包末尾的FCS进行对比，正常情况下两者应该是一致的，如果中途受到噪声干扰而导致波形发生紊乱，则两者的值会产生差异，这时这个包就会被当做错误包而被丢弃。

    如果FCS教研没有问题，接下来就要看一下MAC头部中接收方MAC地址与网卡在初始化时分配给自己的MAC地址是否一致，以判断这个包是不是发给自己的。如果不是自己的包就直接丢弃，如果接收方MAC地址和自己MAC地址一致，则将包放入缓冲区中。到这里，MAC模块的工作就完成了，接下来网卡会通知计算机收到了一个包。

20. 将服务器的响应包从IP传递给TCP

    假设web服务器返回了一个网络包，包的以太类型应该是0800。因此网卡驱动会将其交给TCP/IP协议栈来进行处理。首先轮到IP模块开始工作。如果接收方IP地址不是自己的地址，那一定是发生了什么错误。客户端计算机不负责对包进行转发，因此不应该收到不是发给自己的包，当发生这样的错误时，IP模块会通过 **ICMP** 消息将错误告知发送方。如果接收方的IP地址正确，则这个包会被接收下来。

    IP模块还要完成另一项工作：IP协议有一个叫作分片的功能。网线和局域网中只能传输小包，因此需要将打的包切分成多个小包。如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包，也就是完成一个被称为 **分片重组** 的操作。

    再后面就是TCP模块执行操作了。

21. UDP协议

    UDP没有TCP的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面加上UDP头部，然后交给IP进行发送就可以了。接收也很简单，只要根据IP头部中的接收方和发送方IP地址，以及UDP头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了。

    UDP只负责单纯地发送包而已，遇到错误或者丢包也一概不管，不会像TCP一样会对包的送达状态进行监控。如果出错收不到来自对方的回复，应用程序会注意到这个问题，并重新发送一遍数据。

    DNS、视频和音频数据都使用UDP协议。
