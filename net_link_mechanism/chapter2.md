### 第二章 用电信号传输TCP/IP数据

这一章是讲协议栈（网络控制软件）和网卡（网络硬件）。

1. 协议栈内部结构

![协议栈内部结构](./images/协议栈内部结构.png)

从图中可以看到，协议栈的上半部分有两块，分别是负责用TCP协议收发数据的部分和负责用UDP协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。**像浏览器、邮件等一般的应用程序都是使用TCP收发数据的，而像DNS查询等收发较短的控制数据的时候则使用UDP。**

2. 套接字的实体就是通信控制信息

在 **协议栈内部** 有一块用于 **存放控制信息的内存空间**，这里记录了用于控制通信操作的控制信息，例如通信对象的 **IP地址**、**端口号**、**通信操作的进行状态**等。套接字只是一个概念，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说是存放控制信息的内存空间就是套接字的实体。

*windows*中使用`webstat`来显示套接字，ubuntu中使用`ss`显示类似的信息，更多操作指令见[此处](https://blog.csdn.net/zeweig/article/details/51760624)。

3. 创建套接字

应用程序调用`socket`申请创建套接字。

**创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。**

在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们逍遥开辟u出来这样一块空间，相当与为控制信息准备了一个容器。套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。到这里，创建套接字的操作就完成了。

套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只需要通过描述符确定了相应的套接字，协议栈就能获取所有的相关信息。

4. 连接操作的含义

---
##### 插个嘴

这里插个嘴，之前的笔记里应该是有写错的地方，比如连接这里，书上的写法是：

>创建套接字之后，应用程序（浏览器）就会调用connect，协议栈会将本地的套接字与服务器的套接字进行连接

看到没，是浏览器调用了Socket库中的程序！！！
---

**连接的本质是双方交换控制信息**

套接字刚刚创建完成时，里面并没有存放任何数据，也不知道通信对象是谁。在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。**浏览器**可以根据网址来查询服务器的IP地址，而且根据规则也知道该使用80端口，但只有浏览器知道这些必要的信息是不够的，因为在调用socket创建套接字的时候，这些信息并没有传递给协议栈。因此，**我们需要把服务器的IP地址和端口号等信息告知协议栈，这是连接操作的目的之一。**

服务器上也会创建套接字，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁。 **客户端向服务器传达开始通信的请求，向服务器告知必要的信息，也是连接操作的目的之一。**

当执行数据首发操作时，我们还需要一块用来临时存放要首发的数据的内存空间，这块内存空间称为缓冲区，**它也是在连接操作的过程中分配的。**

##### 控制信息

**控制信息**:用来控制数据收发操作所需的一些信息。

第一类：是客户端和服务器相互联络时交换的控制信息。这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程中都需要。 *这些信息记录在网络包的头部。*

第二类：**保存在套接字中**，用来控制协议栈操作的信息。应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。 *协议栈具体需要哪些信息会根据协议栈本身的实现方式不同而不同。因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。*

5. 连接操作的实际过程

连接操作从应用程序调用Socket库的connect开始：

```
connect(< 描述符 >, < 服务器 IP 地址和端口号 >, ...)
```

*这个地方有点麻烦*