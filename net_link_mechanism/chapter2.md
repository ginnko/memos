### 第二章 用电信号传输TCP/IP数据

这一章是讲协议栈（网络控制软件）和网卡（网络硬件）。

1. 协议栈内部结构

![协议栈内部结构](./images/协议栈内部结构.png)

从图中可以看到，协议栈的上半部分有两块，分别是负责用TCP协议收发数据的部分和负责用UDP协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。**像浏览器、邮件等一般的应用程序都是使用TCP收发数据的，而像DNS查询等收发较短的控制数据的时候则使用UDP。**

2. 套接字的实体就是通信控制信息

在 **协议栈内部** 有一块用于 **存放控制信息的内存空间**，这里记录了用于控制通信操作的控制信息，例如通信对象的 **IP地址**、**端口号**、**通信操作的进行状态**等。套接字只是一个概念，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说是存放控制信息的内存空间就是套接字的实体。

*windows*中使用`webstat`来显示套接字，ubuntu中使用`ss`显示类似的信息，更多操作指令见[此处](https://blog.csdn.net/zeweig/article/details/51760624)。

3. 创建套接字

应用程序调用`socket`申请创建套接字。

**创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。**

在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们逍遥开辟u出来这样一块空间，相当与为控制信息准备了一个容器。套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。到这里，创建套接字的操作就完成了。

套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只需要通过描述符确定了相应的套接字，协议栈就能获取所有的相关信息。

4. 连接操作的含义

---
##### 插个嘴

这里插个嘴，之前的笔记里应该是有写错的地方，比如连接这里，书上的写法是：

>创建套接字之后，应用程序（浏览器）就会调用connect，协议栈会将本地的套接字与服务器的套接字进行连接

看到没，是浏览器调用了Socket库中的程序！！！
---

**连接的本质是双方交换控制信息**

套接字刚刚创建完成时，里面并没有存放任何数据，也不知道通信对象是谁。在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。**浏览器**可以根据网址来查询服务器的IP地址，而且根据规则也知道该使用80端口，但只有浏览器知道这些必要的信息是不够的，因为在调用socket创建套接字的时候，这些信息并没有传递给协议栈。因此，**我们需要把服务器的IP地址和端口号等信息告知协议栈，这是连接操作的目的之一。**

服务器上也会创建套接字，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁。 **客户端向服务器传达开始通信的请求，向服务器告知必要的信息，也是连接操作的目的之一。**

当执行数据首发操作时，我们还需要一块用来临时存放要首发的数据的内存空间，这块内存空间称为缓冲区，**它也是在连接操作的过程中分配的。**

##### 控制信息

**控制信息**:用来控制数据收发操作所需的一些信息。

第一类：是客户端和服务器相互联络时交换的控制信息。这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程中都需要。 *这些信息记录在网络包的头部。*

第二类：**保存在套接字中**，用来控制协议栈操作的信息。应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。 *协议栈具体需要哪些信息会根据协议栈本身的实现方式不同而不同。因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。*

5. 连接操作的实际过程

连接操作从应用程序调用Socket库的connect开始：

```
connect(< 描述符 >, < 服务器 IP 地址和端口号 >, ...)
```

上面的调用提供了服务器的IP地址和端口号，这些信息会传递给协议栈中的TCP模块。然后，TCP模块会与该IP地址对应的对象，也就是与服务器的TCP模块交换控制信息，这一交互过程包括下面几个步骤。

- 首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。
- 然后，我们将头部中的控制位的SYN比特设置为1，可以认为它表示连接；
- 当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送IP模块执行网络包发送操作之后，网络包机会通过网络到达服务器，然后服务器上的IP模块会将收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字。找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。
- 上述操作完成之后，服务器的TCP模块会返回响应，这个过程和客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特。此外，在返回响应时，还需要将ACK控制位设为1，表示已经收到相应的网络包。（**设置ACK比特的目的就是用来在双方通信过程中互相确认网络包是否已经送达。**）
- 接下来，服务器TCP模块会将TCP头部传递给IP模块，并将IP模块向客户端返回响应。然后，网络包就会返回客户端，通过IP模块到达TCP模块，并通过TCP头部的信息确认连接服务器的操作是否成功。如果SYN为1则表示连接成功，这时会向套接字中写入服务器的IP地址、端口号等信息，同时还会将状态改为连接完毕；
- 最后，服务器返回响应时将ACK比特设置为1，相应的，客户端也需要将ACK比特设置为1并返回服务器，告诉服务器刚才的响应包已经收到。当这个服务器收到这个返回包之后，连接操作才算全部完成。

6. 收发数据

```
write()
```

数据收发操作是从应用程序调用`write`将要发送的数据交给协议栈开始的，协议栈收到数据后执行发送操作。

要点：

- 协议栈不关心应用程序传来的数据是什么内容。应用程序在调用`write`时会指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。
- 协议栈并不是一收到数据就马上发送出去，而是会将数据存放在 **内部的发送缓冲区** (*这个缓冲区是什么时候创建的？连接阶段？*)中，并等待应用程序的下一段数据。一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为。

    发送大量的小包会导致网络效率降低。

    判断网络包的大小：

    1. 协议栈会根据一个叫作`MTU`的参数来进行判断。`MTU`表示一个网络包的最大长度，在以太网中一般是1500字节。MTU是包含头部的总长度，因此需要从`MTU`减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作`MSS`。当从应用程序收到的数据长度超过或者接近MSS时再发送出去，就可以避免发送大量小包的问题了。
    2. 另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近MSS时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到MSS，也应该发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。

    上面两个因素是互斥的，协议栈给应用程序保留了控制发送时机的余地。像浏览器这种会话型应用程序再向服务器发送数据时，等待填满缓冲区会导致延迟产生很大影响，因此一般会使用直接发送的选项。

    ##### 对较大数据进行拆分

    提交数据的情况，比如在博客或者论坛上发表一篇长文就属于这种情况。


    ![TCP拆分包](./images/TCP拆分包.PNG)

- 使用ACK号确认网络包已收到

    TCP具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。

    ###### 确认原理

    - 首先，TCP模块在拆分数据时，会先计算好每一块数据相当于 **从头开始的第几个字节**，接下来在发送这一块数据时，将算好的字节数写在TCP头部中，“序号”字段就是派在这个用场上的。
    - 然后，发送数据的长度也需要告知接收方，不过这个并不是放在TCP头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度。

    通过这些信息，接收方还能够检查收到的网络包有没有遗漏，如果确认没有遗漏，接收方会将到目前为止接受到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入TCP头部的ACK号中发送给发送方。这个返回ACK号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据。

    在实际的通信中，序号并不是从1开始的，而是需要用随机数计算出一个初始值，这时因为如果需要都从1开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。**在连接过程中，有一个将SYN控制位设为1并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。实际上，在将SYN设为1的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值。**

    - 双向通信的过程原理：首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算ACK号并返回给客户端；相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算ACK号并返回给服务器。此外，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。


