
### 第一章 概述(2018.3.5)
- 变量定义:首先，变量自动变为一个被称作“活动对象”的内置对象的属性（如果是全局变量的话，就变为全局对象的属性）。第二，这个变量实际上也是“伪对象”，因为它有自己的属性（属性特性），用以表示变量是否可以被修改、删除或在for-in循环中枚举。

- 对象分类:
  - 本地对象:本地对象也可以被归类为内置对象（比如Array，Date）或自定义对象（var o = {}）。
  - 宿主对象: 宿主对象包含window和所有DOM对象。

### 第二章 高质量javascript基本要点(2018.3.5~2018.3.6)
- 避免全局变量的方法: 使用命名空间,立即执行函数.减少全局变量最有效的方法是坚持使用var来声明变量(解释:1.不声明而直接使用变量,这个变量就会成为全局变量;2.'隐式全局对象的概念':任何不通过var声明的变量都会成为全局对象的一个属性)

- 显式创建全局变量vs隐式创建全局变量
  - 通过var创建的全局变量(在任何函数体之外创建的变量)不能被删除;
  - 没有通过var创建的隐式全局变量(不考虑函数内的情况**what?!意思函数内创建的可以被删除**)可以被删除
  - *隐式全局变量不算是真正的变量,它们是全局对象的属性成员.属性可以通过delete运算符删除,变量不能被删除.***在浏览器环境中,全局变量实质都是window下的一个属性,故可以用delete删除,但在nodejs等非浏览器环境下,显式声明的全局变量无法用delete删除(nodejs也有全局对象?)**

- 访问全局对象(**通用的方法,可在多个平台上使用,在严格模式下无效!!!嘛哒!!!**)
```
var global = (function(){
  return this;
})();
```
上述代码可以在任意层次嵌套的函数作用域内执行,因为**在被当做函数执行的函数体内(而不是被当做构造函数执行的函数体内),this总是指向全局对象***这个解释真是好绕啊!!!!!!*

> 比如，如果你在开发一个库，你会将你的代码包装在一个立即执行的匿名函数中（在第四章会讲到），然后从全局作用域中给这个匿名函数传入一个指向this的参数。
**上面这个在underscore中见过,嘻嘻~**

- 单var模式是最佳实践

-for循环
  - 缓存数组,类数组的length属性可以提高效率,特别是针对HTMLCollection对象
  - 从性能角度进行的优化
  ```
  var i, myarray = [];
  for (i = myarray.length; i--;) {
    // do something with myarray[i]
  }
```
>上述代码:1.减少了一个存储length的变量;2.减量循环至零,这种方式更快,因为和零比较要和非零数字或数组长度比较要高效的多

- for in循环
用于**非数组对象**做遍历,也被称作枚举.  

for-in循环中属性的遍历顺序是不固定的,所以**普通数组使用for循环,对象使用for-in循环**

添加hasOwnProperty()的目的:**当你对当前要遍历的对象不确定的时候，添加hasOwnProperty()则更加保险些。**

  - 对象的hasOwnProperty()方法的使用写法:
    1. obj.hasOwnProperty()
    ```
    for (var i in man) {
      if (man.hasOwnProperty(i)) { // filter
        console.log(i, ":", man[i]);
      }
    }
    ```

    2. 通过Object.prototype直接调用hasOwnProperty()方法
    ```
    for (var i in man) {
      if (Object.prototype.hasOwnProperty.call(man, i)) { // filter
        console.log(i, ":", man[i]);
      }
    }
    ```
    >方法2的有点:当man对象中重新定义了hasOwnProperty方法时，可以避免调用时的命名冲突（译注：明确指定调用的是Object.prototype上的方法而不是实例对象中的方法），这种做法同样可以避免冗长的属性查找过程（译注：这种查找过程多是在原型链上进行查找），一直查找到Object中的方法.

  - 缓存hasOwnProperty():
  `var hasOwn = Object.prototype.hasOwnProperty;` **这个在underscore中有见过,嘻嘻~**
- switch模式
该书对于case语句的连续执行给出的态度很有意思诶~
>避免连续执行多个case语句块（当省略break时会发生），如果你坚持认为连续执行多case语句块是最好的方法，请务必补充文档说明，对于其他人来说，这种情况看起来是错误的。

- 避免使用隐式类型转换
方法:使用`===`以及`!==`

- 字符串转换为数字的三种方法
  1. 使用parseInt()
  2. +"08"
  3. Numnber("08)
>说明:后两种方法要比第一种快快,因为顾名思义parseInt()是一种“解析”而不是简单的“转换”。但当你期望将“08 hello”这类字符串转换为数字，则必须使用parseInt()，其他方法都会返回NaN。

- 使用parseInt()进行数字转换
  - 第二个表示基数的参数不能省略,避免'0809'(八月九号)这种字符串产生错误

- 规范
**遵循规范比规范本身要重要**
  - 缩进
    - JSLint使用4个空格
    - ESLint使用2个空格?

  - 空格
  其他的推荐形式都已遵守,要增加一个:
    - **在函数,if-else语句,循环,对象直接量的左花括号之前补充空格**
    - **在右花括号和else和while之间补充空格**

  - 命名规范
    - 构造函数:使用'大驼峰':`MyConstructor()`
    - 普通函数:使用'小驼峰':`myFunction()`
    - 变量名:使用'小驼峰'
    - 常量:使用全部大写字母
    - 全局变量:使用全部大写字母
    - 私有变量:前面加下划线
- 注释需要对所有函数,它们的参数和返回值做补充注释,对于那些有趣的或是怪异的算法和技术也应当配备注释